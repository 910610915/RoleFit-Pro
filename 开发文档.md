# 游戏公司终端性能基准测试与岗位配置分析系�?
# 开发技术文�?
## 文档信息

| 项目 | 内容 |
|------|------|
| 项目名称 | 硬件性能基准测试与岗位配置分析系�?|
| 项目代号 | HardwareBenchmark |
| 版本�?| V1.0.0 |
| 创建日期 | 2026-02-22 |
| 适用场景 | 游戏公司IT部门电脑设备配置选型与性能评估 |
| 架构类型 | 企业级B/S分布式架�?|

---

## 第一�?项目背景与目�?
### 1.1 项目背景

随着游戏开发项目复杂度的不断提升，开发团队对终端设备的性能要求日益严苛。游戏开发涉�?Unreal Engine �?Unity 引擎的编译构建�?D 建模与渲染、动画制作、特效合成等多个专业领域，每个领域对硬件资源的需求各有侧重。然而，当前绝大多数游戏公司在电脑设备配置方面缺乏科学的评估体系和标准化的测试流程，导致以下问题频繁出现�?
配置选型依赖经验判断，缺乏量化数据支撑。IT 部门在采购新设备时，往往根据供应商建议或个人经验进行配置选择，无法准确评估所选配置是否真正满足实际工作需求。部分员工抱怨电脑性能不足影响工作效率，而部分配置却存在明显过剩，造成企业资金浪费�?
传统基准测试工具（如 3DMark、PCMark、Cinebench）虽然能够反映硬件的理论性能，但与实际游戏开发工作场景存在显著差异。跑分成绩高并不意味着在实际工作中表现出色，例�?Cinebench 渲染分数高的 CPU 在编译大�?Unreal Engine 项目时可能表现不佳，因为编译任务还涉及磁�?IO、内存带宽、文件系统缓存等多个维度的综合性能�?
缺乏统一的岗位配置标准是另一个突出问题。不同岗位（程序开发、美术设计、测�?QA、运营策划）对硬件配置的需求差异巨大，但企业往往采用“一刀切”的配置策略，或者虽然知道需要分级配置，但缺乏科学的分级依据和验证手段�?
### 1.2 项目目标

本项目的核心目标是构建一套完整的自动化性能基准测试与岗位配置分析系统，实现以下具体功能�?
第一，建立真实场景模拟能力。通过自动化脚本模拟各岗位员工的实际工作操作（如代码编译、场景加载、模型渲染、动画烘焙），采集操作过程中的真实性能数据，而非仅仅依赖合成跑分�?
第二，实现配置达标判定。基于采集的性能数据，结合预设的岗位配置标准，自动判断当前配置是否满足工作需求，识别性能瓶颈所在，并给出具体的升级建议�?
第三，构建可视化数据分析平台。提供直观的数据可视化大屏，支持多机对比分析、性能趋势追踪、历史数据查询等功能，为管理决策提供数据支撑�?
第四，支持批量自动化测试。通过客户�?服务器架构，实现远程任务下发、自动执行、结果回传，减少人工操作成本，提高测试效率�?
### 1.3 核心价�?
本系统将为企业带来以下核心价值：

量化决策支持。通过客观的性能测试数据替代主观经验判断，让配置选型决策有据可依�?
消除配置浪费。通过资源饱和度分析，识别配置过剩的硬件，避免不必要的采购支出�?
提升采购效率。标准化的测试流程和配置标准，可大幅缩短新设备采购评估周期�?
优化资产配置。基于实际使用数据的岗位配置分级，确保每台设备物尽其用�?
---

## 第二�?系统架构设计

### 2.1 整体架构概览

本系统采用典型的分布�?B/S（Browser/Server）架构设计，由三大核心组件构成：客户端测试代理（Agent）、服务器端后端服务（Server）、前端可视化平台（Web Client）。组件之间通过 HTTP/HTTPS 协议�?WebSocket 长连接进行数据交互，形成完整的测试任务调度、数据采集、存储分析、可视化展示闭环�?
系统架构图如下所示：

```
┌─────────────────────────────────────────────────────────────────────�?�?                         前端可视化层                                 �?�? ┌─────────────�? ┌─────────────�? ┌─────────────�? ┌───────────�?�?�? �? 实时监控   �? �? 测试报告   �? �? 配置管理   �? �? 数据看板  �?�?�? �?  看板      �? �?   页面     �? �?   页面     �? �?          �?�?�? └──────┬──────�? └──────┬──────�? └──────┬──────�? └─────┬─────�?�?└─────────┼────────────────┼────────────────┼───────────────┼───────�?          �?               �?               �?              �?          └────────────────┴────────────────┴───────────────�?                                   �?                          ┌────────▼────────�?                          �?  API 网关�?   �?                          �?  (FastAPI)     �?                          └────────┬────────�?                                   �?          ┌────────────────────────┼────────────────────────�?          �?                       �?                       �?┌─────────▼──────────�?   ┌─────────▼──────────�?  ┌────────▼────────�?�?  任务调度服务     �?   �?  数据分析引擎     �?  �? 设备管理服务   �?�?                  �?   �?                   �?  �?                �?└─────────┬──────────�?   └─────────┬──────────�?  └────────┬────────�?          �?                         �?                     �?          └──────────────────────────┼──────────────────────�?                                     �?                                                    ┌──────────▼──────────�?
                          �?     数据库层        �?
                          �?     SQLite         �?
                          �?  (轻量级嵌入式)    �?
                          └─────────────────────�?                                     �?┌────────────────────────────────────┼────────────────────────────────�?�?                         客户端测试代理层                             �?�? ┌────────────�? ┌────────────�? ┌────────────�? ┌────────────�? �?�? �? 操作模拟   �? �? 性能采集   �? �? 任务执行   �? �? 数据上报   �? �?�? �?  模块     �? �?  模块     �? �?  模块     �? �?  模块     �? �?�? └────────────�? └────────────�? └────────────�? └────────────�? �?�?                             �?                                      �?�?                   ┌─────────▼─────────�?                            �?�?                   �?  被测电脑终端    �?                            �?�?                   └───────────────────�?                            �?└──────────────────────────────────────────────────────────────────────�?```

### 2.2 组件职责说明

#### 2.2.1 客户端测试代理（Agent�?
客户端测试代理是部署在被测电脑上的可执行程序，负责在本地执行测试任务并采集性能数据。该组件采用 Python 语言开发，通过 PyInstaller 打包成单文件 EXE，无需在被测电脑上安装 Python 运行环境即可独立运行。Agent 的核心职责包括：

硬件信息采集：自动识别被测电脑的 CPU、显卡、内存、硬盘等硬件配置信息，生成唯一的设备指纹。性能数据采集：在测试执行过程中实时采�?CPU 使用率、内存占用、GPU 利用率、显存占用、磁�?IO、网�?IO 等多维度性能指标。任务执行：接收服务器下发的测试任务，按照预定义的脚本执行自动化操作序列。数据上报：将采集到的硬件信息和测试结果通过 HTTP POST �?WebSocket 方式上报到服务器。操作模拟：使用 PyAutoGUI、PyDirectInput 等库模拟真实的键盘鼠标操作，实现工作场景回放�?
#### 2.2.2 服务器端后端服务（Server�?
服务器端采用 Python FastAPI 框架构建，提供完整的 RESTful API 接口�?WebSocket 实时通信能力。服务器承担以下核心职责�?
任务调度管理：接收前端下发的测试任务，根据任务配置将任务分发到指定的客户端代理执行。数据接收处理：接收客户端上传的测试数据和性能指标，写入数据库存储。数据分析计算：将采集到的性能数据与预设的配置标准进行对比分析，输出达标判定和升级建议。业务逻辑处理：提供设备管理、用户管理、配置标准管理等业务功能�?
#### 2.2.3 前端可视化平台（Web Client�?
前端采用 Vue 3 框架构建单页面应用，通过 HTTP API 与后端服务通信，通过 WebSocket 接收实时性能数据。前端的主要功能包括�?
实时监控看板：展示当前正在进行的测试任务的实时性能曲线，支持多指标叠加显示。测试报告管理：查看历史测试记录详情，支持报告导出和分享。配置标准管理：维护不同岗位的配置标准，包括性能阈值和达标规则。数据可视化分析：提供多机对比、性能趋势、瓶颈分析等数据可视化功能�?
### 2.3 技术架构选型理由

#### 2.3.1 Python 语言优势

选择 Python 作为核心开发语言基于以下考量�?
丰富的硬件交互库：Python 生态系统拥�?psutil、wmi、pywin32、GPUtil、pynvml 等完善的硬件信息获取和性能监控库，可快速实现硬件指纹识别和性能数据采集。强大的外部程序调用能力：通过 subprocess 模块可以轻松调用 Cinebench、Blender Benchmark�?DMark 等外部基准测试软件的命令行版本，实现标准化测试。便捷的脚本开发：Python 语法简洁易读，便于开发复杂的测试脚本逻辑，特别是处理自动化操作序列和数据解析场景。跨平台部署能力：虽然本系统主要运行�?Windows 环境下，�?Python 代码可轻松移植到 Linux 服务器部署后端服务。数据处理能力：Python 配合 Pandas、NumPy 等库，在数据分析处理方面具有显著优势�?
#### 2.3.2 FastAPI 框架优势

选择 FastAPI 作为后端框架的理由包括：

高性能：FastAPI 基于 Starlette �?Pydantic，性能接近 Go 语言框架，远超传�?Python Web 框架。自动文档：FastAPI 自动生成交互�?API 文档，开发调试极为便利。类型提示：内置 Pydantic 支持强类型验证，提高代码可靠性。异步支持：原生支持异步编程，可高效处理大量并发连接。易于上手：API 设计直观，学习曲线平缓�?
#### 2.3.3 Vue 3 + Naive UI 优势

选择 Vue 3 �?Naive UI 构建前端的原因如下：

Vue 3 Composition API：更好的代码组织方式，逻辑复用更灵活。Naive UI 组件库：企业�?UI 组件库，组件丰富、风格专业、文档完善。Vite 构建工具：极快的开发启动和热更新体验。ECharts 集成：Naive UI �?ECharts 有良好支持，数据可视化实现简单�?
#### 2.3.4 SQLite 数据库优势

选择 SQLite 作为主数据库的理由：

- 零部署：嵌入式数据库，无需安装和配置数据库服务进程，单文件存储，便于备份和迁移。
- 轻量级：库文件仅几 MB，对系统资源需求极低，适合中小规模部署。
- 高性能：对于单用户或低并发场景，SQLite 的读写性能非常出色。
- 导出支持：支持导出为 MySQL/PostgreSQL 格式，便于生产环境迁移。
- 维护简单：无需数据库管理员，备份只需复制文件。
---

## 第三�?技术栈详细清单

### 3.1 后端技术栈

#### 3.1.1 核心框架与语言

| 技术项 | 版本要求 | 说明 |
|--------|----------|------|
| Python | 3.10+ | 推荐使用 Python 3.11 或更高版�?|
| FastAPI | 0.104+ | 后端 Web 框架 |
| Uvicorn | 0.24+ | ASGI 服务�?|
| Pydantic | 2.4+ | 数据验证和序列化 |
| SQLAlchemy | 2.0+ | ORM 框架 |
| Alembic | 1.12+ | 数据库迁移工�?|

#### 3.1.2 数据处理与分�?
| 技术项 | 版本要求 | 说明 |
|--------|----------|------|
| Pandas | 2.0+ | 数据分析处理 |
| NumPy | 1.24+ | 数值计�?|
| SciPy | 1.11+ | 科学计算 |

#### 3.1.3 硬件交互与监�?
| 技术项 | 版本要求 | 说明 |
|--------|----------|------|
| psutil | 5.9+ | 系统硬件信息与性能监控 |
| wmi | 1.5+ | Windows 硬件信息查询 |
| GPUtil | 1.4+ | GPU 状态监控（NVIDIA�?|
| pynvml | 11.5+ | NVIDIA GPU 底层管理接口 |
| pywin32 | 306+ | Windows 系统 API 调用 |
| pythonnet | 3.0+ | .NET 互操作（用于调用 LibreHardwareMonitor�?|

#### 3.1.4 数据库
| 技术项 | 版本要求 | 说明 |
|--------|----------|------|
| SQLite | 3.x | 轻量级嵌入式数据库 |

#### 3.1.5 其他辅助�?
| 技术项 | 版本要求 | 说明 |
|--------|----------|------|
| python-multipart | 0.0.6+ | 文件上传处理 |
| python-jose | 3.3.0+ | JWT 令牌处理 |
| passlib | 1.7.4+ | 密码加密 |
| python-dotenv | 1.0+ | 环境变量管理 |
| aiofiles | 23.2+ | 异步文件操作 |
| httpx | 0.25+ | 异步 HTTP 客户�?|

### 3.2 前端技术栈

#### 3.2.1 核心框架与构�?
| 技术项 | 版本要求 | 说明 |
|--------|----------|------|
| Vue | 3.3+ | 前端框架 |
| Vite | 5.0+ | 构建工具 |
| TypeScript | 5.0+ | 类型系统 |
| Pinia | 2.1+ | 状态管�?|
| Vue Router | 4.2+ | 路由管理 |

#### 3.2.2 UI 组件�?
| 技术项 | 版本要求 | 说明 |
|--------|----------|------|
| Naive UI | 3.7+ | 企业�?UI 组件�?|
| @vueuse/core | 10.7+ | Vue 组合式工具库 |

#### 3.2.3 数据可视�?
| 技术项 | 版本要求 | 说明 |
|--------|----------|------|
| ECharts | 5.4+ | 图表可视化库 |
| vue-echarts | 6.6+ | ECharts Vue 封装 |

#### 3.2.4 网络与工�?
| 技术项 | 版本要求 | 说明 |
|--------|----------|------|
| Axios | 1.6+ | HTTP 客户�?|
| dayjs | 1.11+ | 日期时间处理 |
| lodash-es | 4.17+ | 工具函数�?|

### 3.3 客户�?Agent 技术栈

#### 3.3.1 核心开�?
| 技术项 | 版本要求 | 说明 |
|--------|----------|------|
| Python | 3.10+ | 核心开发语言 |
| PyInstaller | 6.3+ | EXE 打包工具 |

#### 3.3.2 自动化操�?
| 技术项 | 版本要求 | 说明 |
|--------|----------|------|
| PyAutoGUI | 0.9+ | 键盘鼠标自动化操�?|
| PyDirectInput | 0.9+ | DirectInput 游戏输入模拟 |
| pytesseract | 0.3+ | 光学字符识别（用于界面识别） |
| opencv-python | 4.8+ | 图像处理（用于视觉定位） |

#### 3.3.3 数据采集

| 技术项 | 版本要求 | 说明 |
|--------|----------|------|
| psutil | 5.9+ | 系统性能监控 |
| wmi | 1.5+ | 硬件信息获取 |
| GPUtil | 1.4+ | GPU 监控 |
| pynvml | 11.5+ | NVIDIA GPU 底层接口 |
| winstats | 1.0+ | Windows 性能计数�?|

#### 3.3.4 数据上报

| 技术项 | 版本要求 | 说明 |
|--------|----------|------|
| requests | 2.31+ | HTTP 客户�?|
| websocket-client | 1.6+ | WebSocket 客户�?|
| schedule | 1.2+ | 定时任务调度 |

### 3.4 数据库技术栈

| 技术项 | 版本要求 | 说明 |
|--------|----------|------|
| SQLite | 3.x | 轻量级嵌入式数据库，无需单独部署 |

> 注：系统使用 SQLite 作为主数据库，支持导出为 MySQL/PostgreSQL 格式用于生产环境迁移。

### 3.5 基础设施与部�?
| 技术项 | 版本要求 | 说明 |
|--------|----------|------|
| Docker | 24.0+ | 容器化部�?|
| Docker Compose | 2.20+ | 多容器编�?|
| Nginx | 1.24+ | Web 服务器与反向代理 |
| GitLab CI/CD | 15+ | 持续集成与部�?|

---

## 第四�?数据库设�?
### 4.1 数据库总体架构

本系统采用 SQLite 轻量级嵌入式数据库。SQLite 无需单独部署，数据库以单文件形式存储，便于备份和迁移。系统支持将数据导出为 MySQL SQL 语句或 PostgreSQL SQL 语句，方便后续迁移到生产环境的大型数据库。
### 4.2 SQLite 表结构设�?
#### 4.2.1 用户管理表（users�?
```sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(50) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    email VARCHAR(100) UNIQUE,
    full_name VARCHAR(100),
    role VARCHAR(20) DEFAULT 'user' CHECK(role IN ('admin', 'operator', 'viewer')),
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
```

#### 4.2.2 设备资产表（devices�?
```sql
CREATE TABLE devices (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    device_name VARCHAR(100) NOT NULL,
    mac_address VARCHAR(17) UNIQUE NOT NULL,
    ip_address VARCHAR(15),
    hostname VARCHAR(100),
    
    -- 硬件信息
    cpu_model VARCHAR(200),
    cpu_cores INT,
    cpu_threads INT,
    cpu_base_clock FLOAT,
    
    gpu_model VARCHAR(200),
    gpu_vram_mb INT,
    gpu_driver_version VARCHAR(50),
    
    ram_total_gb FLOAT,
    ram_frequency INT,
    
    disk_model VARCHAR(200),
    disk_capacity_tb FLOAT,
    disk_type VARCHAR(20), -- NVMe, SATA, SSD, HDD
    
    os_name VARCHAR(50),
    os_version VARCHAR(50),
    os_build VARCHAR(20),
    
    -- 关联信息
    department VARCHAR(100),
    position VARCHAR(100),
    assigned_to VARCHAR(100),
    
    -- 状�?    status VARCHAR(20) DEFAULT 'offline' CHECK (status IN ('online', 'offline', 'testing', 'error')),
    last_seen_at TIMESTAMP WITH TIME ZONE,
    registered_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    -- 备注
    notes TEXT
);

CREATE INDEX idx_devices_mac ON devices(mac_address);
CREATE INDEX idx_devices_status ON devices(status);
CREATE INDEX idx_devices_department ON devices(department);
CREATE INDEX idx_devices_position ON devices(position);
```

#### 4.2.3 岗位配置标准表（position_standards�?
```sql
CREATE TABLE position_standards (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    position_name VARCHAR(100) UNIQUE NOT NULL,
    position_code VARCHAR(50) UNIQUE NOT NULL,
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    
    -- CPU 要求
    cpu_min_cores INT,
    cpu_min_threads INT,
    cpu_min_score INT, -- PassMark 分数参考�?    cpu_max_usage_percent FLOAT DEFAULT 80.0,
    
    -- 内存要求
    ram_min_gb FLOAT,
    ram_max_usage_percent FLOAT DEFAULT 85.0,
    
    -- 显卡要求
    gpu_model_pattern VARCHAR(200), -- 匹配模式，如 "RTX.*|GTX.*"
    gpu_min_vram_mb INT,
    gpu_min_score INT,
    gpu_max_usage_percent FLOAT DEFAULT 90.0,
    
    -- 存储要求
    disk_min_capacity_tb FLOAT,
    disk_min_read_mbps FLOAT, -- 最低顺序读取速度 MB/s
    disk_min_write_mbps FLOAT,
    disk_min_iops INT, -- 4K 随机 IOPS
    
    -- 业务场景要求
    compile_time_max_seconds INT, -- 单次编译最大耗时
    viewport_fps_min INT, -- 视口最小帧�?    render_time_max_seconds INT, -- 单次渲染最大耗时
    app_launch_max_seconds INT, -- 软件启动最大耗时
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    created_by UUID REFERENCES users(id)
);

COMMENT ON TABLE position_standards IS '岗位配置标准定义�?;
```

#### 4.2.4 测试任务表（test_tasks�?
```sql
CREATE TABLE test_tasks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    task_name VARCHAR(200) NOT NULL,
    task_type VARCHAR(50) NOT NULL CHECK (task_type IN ('benchmark', 'simulation', 'full', 'custom')),
    task_status VARCHAR(20) DEFAULT 'pending' CHECK (task_status IN ('pending', 'running', 'completed', 'failed', 'cancelled')),
    
    -- 目标设备
    target_device_ids UUID[] DEFAULT '{}',
    target_departments VARCHAR[] DEFAULT '{}',
    target_positions VARCHAR[] DEFAULT '{}',
    
    -- 测试配置
    test_script_id UUID, -- 关联测试脚本
    test_duration_seconds INT, -- 测试持续时间
    sample_interval_ms INT DEFAULT 1000, -- 采样间隔毫秒
    
    -- 执行信息
    assigned_agent_id VARCHAR(100),
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE,
    
    -- 调度配置
    schedule_type VARCHAR(20) CHECK (schedule_type IN ('immediate', 'scheduled', 'recurring')),
    scheduled_at TIMESTAMP WITH TIME ZONE,
    cron_expression VARCHAR(100),
    
    -- 创建�?    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_tasks_status ON test_tasks(task_status);
CREATE INDEX idx_tasks_created_by ON test_tasks(created_by);
CREATE INDEX idx_tasks_scheduled_at ON test_tasks(scheduled_at);
```

#### 4.2.5 测试脚本表（test_scripts�?
```sql
CREATE TABLE test_scripts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    script_name VARCHAR(200) NOT NULL,
    script_code VARCHAR(50) UNIQUE NOT NULL,
    description TEXT,
    
    -- 适用岗位
    target_positions VARCHAR[] DEFAULT '{}',
    
    -- 脚本类型
    script_type VARCHAR(20) DEFAULT 'operation' CHECK (script_type IN ('benchmark', 'operation', 'mixed')),
    
    -- 脚本内容（JSON 格式�?    script_content JSONB NOT NULL,
    
    -- 执行参数
    timeout_seconds INT DEFAULT 3600,
    retry_count INT DEFAULT 0,
    
    -- 状�?    is_active BOOLEAN DEFAULT TRUE,
    version INT DEFAULT 1,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    created_by UUID REFERENCES users(id)
);

COMMENT ON TABLE test_scripts IS '测试脚本定义表，script_content 存储 JSON 格式的操作序�?;
```

#### 4.2.6 测试结果表（test_results�?
```sql
CREATE TABLE test_results (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    task_id UUID REFERENCES test_tasks(id),
    device_id UUID REFERENCES devices(id),
    
    -- 测试概况
    test_type VARCHAR(50),
    test_status VARCHAR(20) CHECK (test_status IN ('passed', 'failed', 'warning', 'partial')),
    start_time TIMESTAMP WITH TIME ZONE NOT NULL,
    end_time TIMESTAMP WITH TIME ZONE NOT NULL,
    duration_seconds INT NOT NULL,
    
    -- 测试得分（汇总）
    overall_score FLOAT,
    cpu_score FLOAT,
    gpu_score FLOAT,
    memory_score FLOAT,
    disk_score FLOAT,
    
    -- 配置达标判定
    is_standard_met BOOLEAN,
    standard_id UUID REFERENCES position_standards(id),
    fail_reasons JSONB, -- 不达标原因列�?    
    -- 性能摘要
    performance_summary JSONB, -- 关键指标摘要
    
    -- 瓶颈分析
    bottleneck_type VARCHAR(50), -- CPU, GPU, MEMORY, DISK, NONE
    bottleneck_detail JSONB,
    
    -- 升级建议
    upgrade_suggestion JSONB,
    
    -- 结果文件路径
    result_file_path VARCHAR(500),
    log_file_path VARCHAR(500),
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_results_task_id ON test_results(task_id);
CREATE INDEX idx_results_device_id ON test_results(device_id);
CREATE INDEX idx_results_test_status ON test_results(test_status);
CREATE INDEX idx_results_created_at ON test_results(created_at);
```

#### 4.2.7 系统配置表（system_config�?
```sql
CREATE TABLE system_config (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    config_key VARCHAR(100) UNIQUE NOT NULL,
    config_value JSONB NOT NULL,
    config_type VARCHAR(20) DEFAULT 'string',
    description TEXT,
    is_system BOOLEAN DEFAULT FALSE,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_by UUID REFERENCES users(id)
);

-- 初始化默认配�?INSERT INTO system_config (config_key, config_value, config_type, description, is_system) VALUES
('server', '{"host": "0.0.0.0", "port": 8000, "debug": false}', 'object', '服务器配�?, true),
('agent', '{"heartbeat_interval": 30, "data_upload_interval": 5, "max_retry": 3}', 'object', '客户�?Agent 配置', true),
('benchmark', '{"default_timeout": 3600, "sample_interval": 1000}', 'object', '基准测试默认配置', true);
```

### 4.3 数据导入/导出功能

系统支持将 SQLite 数据导出为 MySQL 或 PostgreSQL 格式，便于迁移到生产环境：

#### 4.3.1 导出为 MySQL 格式
- 导出所有表结构和数据为 MySQL 兼容的 SQL 语句
- 自动处理数据类型映射

#### 4.3.2 导出为 PostgreSQL 格式
- 导出所有表结构和数据为 PostgreSQL 兼容的 SQL 语句
- 自动处理 UUID、JSON 等数据类型

---

## 第五�?后端 API 设计

### 5.1 API 总体设计

后端 API 采用 RESTful 设计风格，URL 路径遵循资源命名规范，使�?HTTP 方法语义表达操作类型。响应格式统一采用 JSON，包含状态码、消息、数据体等标准字段�?
#### 5.1.1 响应格式规范

成功响应格式�?
```json
{
  "code": 200,
  "message": "success",
  "data": {
    // 业务数据
  },
  "timestamp": "2026-02-22T10:30:00Z"
}
```

错误响应格式�?
```json
{
  "code": 400,
  "message": "参数错误",
  "error": {
    "field": "device_id",
    "detail": "设备 ID 格式不正�?
  },
  "timestamp": "2026-02-22T10:30:00Z"
}
```

#### 5.1.2 认证与授�?
系统采用 JWT Token 进行身份认证。用户登录后获取 Access Token �?Refresh Token，访问受保护资源时需要在请求头中携带 Access Token�?
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

权限角色说明�?
| 角色 | 权限说明 |
|------|----------|
| admin | 超级管理员，拥有所有权�?|
| operator | 操作员，可执行测试任务、查看结�?|
| viewer | 查看者，仅可查看数据 |

### 5.2 认证接口

#### 5.2.1 用户登录

```
POST /api/v1/auth/login
```

请求参数�?
```json
{
  "username": "admin",
  "password": "password123"
}
```

响应示例�?
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "access_token": "eyJhbGciOiJIUzI1NiIs...",
    "refresh_token": "eyJhbGciOiJIUzI1NiIs...",
    "expires_in": 7200,
    "token_type": "Bearer",
    "user": {
      "id": "uuid",
      "username": "admin",
      "full_name": "管理�?,
      "role": "admin"
    }
  }
}
```

#### 5.2.2 刷新 Token

```
POST /api/v1/auth/refresh
```

请求参数�?
```json
{
  "refresh_token": "eyJhbGciOiJIUzI1NiIs..."
}
```

### 5.3 设备管理接口

#### 5.3.1 获取设备列表

```
GET /api/v1/devices
```

Query 参数�?
| 参数�?| 类型 | 必填 | 说明 |
|--------|------|------|------|
| page | int | �?| 页码，默�?1 |
| page_size | int | �?| 每页数量，默�?20 |
| status | string | �?| 设备状态筛�?|
| department | string | �?| 部门筛�?|
| position | string | �?| 岗位筛�?|
| keyword | string | �?| 关键词搜索（设备名、MAC 地址�?|

响应示例�?
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "total": 100,
    "page": 1,
    "page_size": 20,
    "items": [
      {
        "id": "uuid",
        "device_name": "美术设计-001",
        "mac_address": "00:11:22:33:44:55",
        "status": "online",
        "department": "美术�?,
        "position": "3D美术",
        "cpu_model": "Intel i7-14700K",
        "gpu_model": "NVIDIA RTX 4080",
        "ram_total_gb": 64,
        "last_seen_at": "2026-02-22T10:00:00Z"
      }
    ]
  }
}
```

#### 5.3.2 获取设备详情

```
GET /api/v1/devices/{device_id}
```

响应示例�?
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "id": "uuid",
    "device_name": "美术设计-001",
    "mac_address": "00:11:22:33:44:55",
    "hostname": "ART-PC-001",
    "ip_address": "192.168.1.101",
    "cpu_model": "Intel i7-14700K",
    "cpu_cores": 20,
    "cpu_threads": 28,
    "cpu_base_clock": 3.4,
    "gpu_model": "NVIDIA RTX 4080",
    "gpu_vram_mb": 16384,
    "gpu_driver_version": "536.99",
    "ram_total_gb": 64,
    "ram_frequency": 5600,
    "disk_model": "三星 990 PRO 2TB",
    "disk_capacity_tb": 2,
    "disk_type": "NVMe",
    "os_name": "Windows 11",
    "os_version": "23H2",
    "os_build": "22631.3155",
    "department": "美术�?,
    "position": "3D美术",
    "assigned_to": "张三",
    "status": "online",
    "registered_at": "2026-01-15T08:30:00Z",
    "last_seen_at": "2026-02-22T10:00:00Z"
  }
}
```

#### 5.3.3 更新设备信息

```
PUT /api/v1/devices/{device_id}
```

请求参数�?
```json
{
  "device_name": "美术设计-001",
  "department": "美术�?,
  "position": "3D美术",
  "assigned_to": "张三",
  "notes": "主要使用 Maya、Substance Painter"
}
```

#### 5.3.4 删除设备

```
DELETE /api/v1/devices/{device_id}
```

### 5.4 测试任务接口

#### 5.4.1 创建测试任务

```
POST /api/v1/tasks
```

请求参数�?
```json
{
  "task_name": "美术部电脑性能评估",
  "task_type": "full",
  "target_device_ids": ["uuid1", "uuid2"],
  "target_departments": ["美术�?],
  "test_script_id": "uuid",
  "test_duration_seconds": 1800,
  "sample_interval_ms": 1000,
  "schedule_type": "immediate"
}
```

响应示例�?
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "id": "uuid",
    "task_name": "美术部电脑性能评估",
    "task_status": "pending",
    "created_at": "2026-02-22T10:30:00Z"
  }
}
```

#### 5.4.2 获取任务列表

```
GET /api/v1/tasks
```

Query 参数�?
| 参数�?| 类型 | 必填 | 说明 |
|--------|------|------|------|
| page | int | �?| 页码 |
| page_size | int | �?| 每页数量 |
| status | string | �?| 任务状态筛�?|
| task_type | string | �?| 任务类型筛�?|
| start_date | string | �?| 开始日期筛�?|
| end_date | string | �?| 结束日期筛�?|

#### 5.4.3 获取任务详情

```
GET /api/v1/tasks/{task_id}
```

响应示例�?
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "id": "uuid",
    "task_name": "美术部电脑性能评估",
    "task_type": "full",
    "task_status": "running",
    "target_device_count": 10,
    "completed_count": 5,
    "failed_count": 0,
    "progress_percent": 50,
    "started_at": "2026-02-22T10:30:00Z",
    "estimated_completion": "2026-02-22T11:30:00Z",
    "created_by": "admin",
    "created_at": "2026-02-22T10:25:00Z"
  }
}
```

#### 5.4.4 获取任务设备详情

```
GET /api/v1/tasks/{task_id}/devices
```

此接口返回任务的执行设备列表及每台设备的执行状态�?
#### 5.4.5 取消任务

```
POST /api/v1/tasks/{task_id}/cancel
```

### 5.5 测试结果接口

#### 5.5.1 获取结果列表

```
GET /api/v1/results
```

Query 参数�?
| 参数�?| 类型 | 必填 | 说明 |
|--------|------|------|------|
| page | int | �?| 页码 |
| page_size | int | �?| 每页数量 |
| device_id | string | �?| 设备 ID 筛�?|
| task_id | string | �?| 任务 ID 筛�?|
| test_status | string | �?| 测试状态筛�?|
| is_standard_met | bool | �?| 是否达标筛�?|
| start_date | string | �?| 开始日�?|
| end_date | string | �?| 结束日期 |

#### 5.5.2 获取结果详情

```
GET /api/v1/results/{result_id}
```

响应示例�?
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "id": "uuid",
    "task_id": "uuid",
    "device_id": "uuid",
    "device_name": "美术设计-001",
    "test_type": "full",
    "test_status": "failed",
    "start_time": "2026-02-22T10:30:00Z",
    "end_time": "2026-02-22T11:00:00Z",
    "duration_seconds": 1800,
    
    "overall_score": 65.5,
    "cpu_score": 85.0,
    "gpu_score": 72.0,
    "memory_score": 90.0,
    "disk_score": 55.0,
    
    "is_standard_met": false,
    "standard_id": "uuid",
    "standard_name": "3D美术标准",
    "fail_reasons": [
      "GPU 渲染性能不足",
      "视口帧率未达�?
    ],
    
    "bottleneck_type": "GPU",
    "bottleneck_detail": {
      "current_gpu": "RTX 3060",
      "gpu_utilization": 98,
      "recommendation": "升级�?RTX 4070 或更�?
    },
    
    "upgrade_suggestion": {
      "priority": "high",
      "recommendations": [
        {
          "component": "GPU",
          "current": "RTX 3060 12GB",
          "recommended": "RTX 4070 12GB",
          "estimated_cost": 4500,
          "expected_improvement": "40%"
        }
      ],
      "total_estimated_cost": 4500,
      "roi_analysis": "升级后可满足 3D 美术岗位需求，预计提升工作效率 30%"
    },
    
    "performance_summary": {
      "cpu_avg_usage": 45,
      "cpu_max_usage": 95,
      "memory_avg_usage": 60,
      "memory_peak_usage": 85,
      "gpu_avg_usage": 85,
      "gpu_max_usage": 99,
      "gpu_memory_avg_usage": 75,
      "disk_read_avg": 500,
      "disk_write_avg": 300
    },
    
    "created_at": "2026-02-22T11:00:00Z"
  }
}
```

#### 5.5.3 获取性能曲线数据

```
GET /api/v1/results/{result_id}/metrics
```

Query 参数�?
| 参数�?| 类型 | 必填 | 说明 |
|--------|------|------|------|
| metric_type | string | �?| 指标类型（cpu, memory, gpu, disk, network�?|
| start_time | string | �?| 开始时�?|
| end_time | string | �?| 结束时间 |
| interval | string | �?| 聚合间隔（raw, 1s, 1m, 5m�?|

响应示例�?
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "metric_type": "cpu",
    "start_time": "2026-02-22T10:30:00Z",
    "end_time": "2026-02-22T11:00:00Z",
    "points": [
      {
        "timestamp": "2026-02-22T10:30:00Z",
        "value": 25.5
      },
      {
        "timestamp": "2026-02-22T10:30:01Z",
        "value": 28.3
      }
    ]
  }
}
```

#### 5.5.4 导出测试报告

```
GET /api/v1/results/{result_id}/export
```

Query 参数�?
| 参数�?| 类型 | 必填 | 说明 |
|--------|------|------|------|
| format | string | �?| 导出格式（pdf, html, json�?|

### 5.6 配置标准管理接口

#### 5.6.1 获取配置标准列表

```
GET /api/v1/standards
```

#### 5.6.2 创建配置标准

```
POST /api/v1/standards
```

请求参数�?
```json
{
  "position_name": "3D美术",
  "position_code": "3D_ARTIST",
  "description": "3D 美术设计师岗位配置标�?,
  
  "cpu_min_cores": 8,
  "cpu_min_threads": 16,
  "cpu_min_score": 20000,
  "cpu_max_usage_percent": 80.0,
  
  "ram_min_gb": 32,
  "ram_max_usage_percent": 85.0,
  
  "gpu_model_pattern": "RTX.*|GTX.*",
  "gpu_min_vram_mb": 8192,
  "gpu_min_score": 15000,
  "gpu_max_usage_percent": 90.0,
  
  "disk_min_capacity_tb": 1,
  "disk_min_read_mbps": 3000,
  "disk_min_write_mbps": 2000,
  "disk_min_iops": 500000,
  
  "viewport_fps_min": 30,
  "render_time_max_seconds": 600,
  "app_launch_max_seconds": 30
}
```

#### 5.6.3 更新配置标准

```
PUT /api/v1/standards/{standard_id}
```

#### 5.6.4 删除配置标准

```
DELETE /api/v1/standards/{standard_id}
```

### 5.7 测试脚本管理接口

#### 5.7.1 获取脚本列表

```
GET /api/v1/scripts
```

#### 5.7.2 创建脚本

```
POST /api/v1/scripts
```

请求参数示例（JSON 格式的脚本内容）�?
```json
{
  "script_name": "3D美术标准测试",
  "script_code": "3D_ARTIST_TEST",
  "description": "适用�?3D 美术岗位的性能测试脚本",
  "target_positions": ["3D美术", "动作美术"],
  "script_type": "mixed",
  "timeout_seconds": 3600,
  "script_content": {
    "version": "1.0",
    "operations": [
      {
        "name": "系统信息采集",
        "type": "gather",
        "timeout": 30
      },
      {
        "name": "Cinebench CPU 测试",
        "type": "benchmark",
        "tool": "cinebench",
        "params": {
          "r23": true,
          "multi_core": true,
          "min_test_duration": 60
        },
        "timeout": 300
      },
      {
        "name": "Blender 渲染测试",
        "type": "benchmark",
        "tool": "blender",
        "params": {
          "scene": "bmw27",
          "device": "GPU"
        },
        "timeout": 600
      },
      {
        "name": "磁盘速度测试",
        "type": "benchmark",
        "tool": "crystaldiskmark",
        "params": {
          "test_size": "32G",
          "profile": " 游戏"
        },
        "timeout": 300
      },
      {
        "name": "Maya 场景加载测试",
        "type": "operation",
        "action": "launch_app",
        "params": {
          "app_path": "D:\\Program Files\\Autodesk\\Maya2024\\bin\\maya.exe",
          "wait_ready": 60
        }
      },
      {
        "name": "视口帧率测试",
        "type": "operation",
        "action": "viewport_test",
        "params": {
          "scene_file": "\\\\fileserver\\test_assets\\heavy_scene.mb",
          "duration": 30,
          "modes": ["wireframe", "shaded", "textured"]
        }
      },
      {
        "name": "渲染测试",
        "type": "operation",
        "action": "render_test",
        "params": {
          "renderer": "arnold",
          "frame": 1,
          "resolution": [1920, 1080]
        }
      }
    ]
  }
}
```

#### 5.7.3 更新脚本

```
PUT /api/v1/scripts/{script_id}
```

#### 5.7.4 删除脚本

```
DELETE /api/v1/scripts/{script_id}
```

#### 5.7.5 测试脚本预览

```
GET /api/v1/scripts/{script_id}/preview
```

此接口返回脚本内容的格式化预览，方便确认脚本逻辑是否正确�?
### 5.8 设备注册与心跳接�?
#### 5.8.1 设备注册

```
POST /api/v1/agent/register
```

此接口供客户�?Agent 调用，用于首次注册设备�?
请求参数�?
```json
{
  "device_name": "美术设计-001",
  "hostname": "ART-PC-001",
  "mac_address": "00:11:22:33:44:55",
  "ip_address": "192.168.1.101",
  "agent_version": "1.0.0",
  "os_info": {
    "platform": "Windows",
    "version": "10.0.22631",
    "machine": "x86_64"
  }
}
```

#### 5.8.2 设备心跳

```
POST /api/v1/agent/heartbeat
```

此接口供客户�?Agent 定期调用，报告设备在线状态�?
请求参数�?
```json
{
  "mac_address": "00:11:22:33:44:55",
  "status": "idle",
  "current_task_id": null,
  "system_info": {
    "cpu_usage": 15.5,
    "memory_usage": 60.2,
    "gpu_usage": 5.0
  }
}
```

#### 5.8.3 上传测试结果

```
POST /api/v1/agent/upload
```

此接口供客户�?Agent 上传测试结果数据�?
请求参数�?multipart/form-data 格式，包�?result.json 文件和可选的日志文件、截图等附件�?
### 5.9 仪表盘数据接�?
#### 5.9.1 仪表盘概�?
```
GET /api/v1/dashboard/overview
```

响应示例�?
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "total_devices": 150,
    "online_devices": 120,
    "testing_devices": 10,
    "offline_devices": 20,
    
    "today_tests": 15,
    "total_tests": 500,
    "pass_rate": 75.5,
    
    "recent_alerts": [
      {
        "device_name": "程序开�?005",
        "alert_type": "performance_warning",
        "message": "CPU 使用率持续偏�?,
        "created_at": "2026-02-22T10:00:00Z"
      }
    ],
    
    "department_summary": [
      {
        "department": "程序�?,
        "total_devices": 50,
        "avg_score": 82.5,
        "pass_rate": 85.0
      },
      {
        "department": "美术�?,
        "total_devices": 60,
        "avg_score": 78.0,
        "pass_rate": 72.0
      }
    ]
  }
}
```

#### 5.9.2 性能趋势数据

```
GET /api/v1/dashboard/trends
```

Query 参数�?
| 参数�?| 类型 | 必填 | 说明 |
|--------|------|------|------|
| metric | string | �?| 指标类型 |
| period | string | �?| 时间周期�?d, 30d, 90d�?|
| group_by | string | �?| 分组方式（department, position�?|

---

## 第六�?客户�?Agent 设计

### 6.1 Agent 架构概览

客户�?Agent 是部署在被测电脑上的独立程序，采用模块化设计，由以下核心模块组成：硬件信息采集模块负责自动识别和采集电脑硬件配置信息；性能监控模块负责实时采集系统性能指标数据；任务执行引擎负责解析和执行服务器下发的测试任务；操作模拟模块负责模拟真实的键盘鼠标操作；数据上报模块负责将采集到的数据上报到服务器�?
Agent 程序经过 PyInstaller 打包后生成单�?EXE 文件，可在任�?Windows 10/11 系统上直接运行，无需安装 Python 环境或额外依赖�?
### 6.2 硬件信息采集

#### 6.2.1 CPU 信息采集

```python
import psutil
import platform

def get_cpu_info():
    """采集 CPU 详细信息"""
    cpu_info = {
        "model": platform.processor(),
        "cores": psutil.cpu_count(logical=False),
        "threads": psutil.cpu_count(logical=True),
        "base_clock_mhz": get_cpu_base_clock(),  # 需要额外查�?        "current_freq_mhz": psutil.cpu_freq().current if psutil.cpu_freq() else None,
        "usage_percent": psutil.cpu_percent(interval=1),
        "per_cpu_usage": psutil.cpu_percent(interval=1, percpu=True)
    }
    
    # 获取 CPU 温度（如果可用）
    try:
        cpu_info["temperature_c"] = get_cpu_temperature()
    except:
        cpu_info["temperature_c"] = None
    
    # 获取 CPU 功耗（如果可用�?    try:
        cpu_info["power_watts"] = get_cpu_power()
    except:
        cpu_info["power_watts"] = None
    
    return cpu_info

def get_cpu_base_clock():
    """获取 CPU 基准频率 - 通过 WMI 查询"""
    import wmi
    c = wmi.WMI()
    for processor in c.Win32_Processor():
        return float(processor.MaxClockSpeed)
    return None
```

#### 6.2.2 内存信息采集

```python
def get_memory_info():
    """采集内存详细信息"""
    mem = psutil.virtual_memory()
    
    return {
        "total_gb": round(mem.total / (1024**3), 2),
        "available_gb": round(mem.available / (1024**3), 2),
        "used_gb": round(mem.used / (1024**3), 2),
        "usage_percent": mem.percent,
        "type": "DDR5" if detect_ddr5() else "DDR4",  # 需要额外检�?        "frequency_mhz": get_memory_frequency()  # 需要额外查�?    }
```

#### 6.2.3 显卡信息采集

```python
import GPUtil

def get_gpu_info():
    """采集显卡详细信息"""
    gpus = GPUtil.getGPUs()
    
    if not gpus:
        return None
    
    gpu_list = []
    for gpu in gpus:
        gpu_info = {
            "id": gpu.id,
            "name": gpu.name,
            "memory_total_mb": gpu.memoryTotal,
            "memory_used_mb": gpu.memoryUsed,
            "memory_free_mb": gpu.memoryFree,
            "memory_percent": gpu.memoryUtil * 100,
            "usage_percent": gpu.load * 100,
            "temperature_c": gpu.temperature,
            "driver_version": gpu.driver
        }
        
        # 通过 pynvml 获取更详细信�?        try:
            gpu_info.update(get_nvml_details(gpu.id))
        except:
            pass
            
        gpu_list.append(gpu_info)
    
    return gpu_list

def get_nvml_details(gpu_id):
    """通过 NVML 获取更详细的 GPU 信息"""
    import pynvml
    pynvml.nvmlInit()
    
    handle = pynvml.nvmlDeviceGetHandleByIndex(gpu_id)
    
    # 核心频率
    clock_info = pynvml.nvmlDeviceGetClockInfo(handle)
    
    # 功�?    power_usage = pynvml.nvmlDeviceGetPowerUsage(handle) / 1000.0  # 毫瓦转瓦
    
    # 显存详细信息
    mem_info = pynvml.nvmlDeviceGetMemoryInfo(handle)
    
    pynvml.nvmlShutdown()
    
    return {
        "core_clock_mhz": clock_info.clock,
        "memory_clock_mhz": clock_info.memClock,
        "power_watts": power_usage,
        "power_limit_watts": pynvml.nvmlDeviceGetPowerManagementLimit(handle) / 1000.0
    }
```

#### 6.2.4 磁盘信息采集

```python
import psutil

def get_disk_info():
    """采集磁盘详细信息"""
    disks = []
    
    for partition in psutil.disk_partitions():
        try:
            usage = psutil.disk_usage(partition.mountpoint)
            disk_type = detect_disk_type(partition.device)  # 需要额外检�?            
            disk_info = {
                "device": partition.device,
                "mountpoint": partition.mountpoint,
                "fstype": partition.fstype,
                "total_gb": round(usage.total / (1024**3), 2),
                "used_gb": round(usage.used / (1024**3), 2),
                "free_gb": round(usage.free / (1024**3), 2),
                "usage_percent": usage.percent,
                "disk_type": disk_type  # NVMe, SATA, SSD, HDD
            }
            
            # 尝试获取磁盘型号
            try:
                disk_info["model"] = get_disk_model(partition.device)
            except:
                disk_info["model"] = None
                
            disks.append(disk_info)
        except:
            continue
    
    return disks
```

### 6.3 性能数据采集

#### 6.3.1 系统级性能监控

```python
import psutil
import time
from threading import Thread, Event

class PerformanceMonitor:
    """性能数据采集�?""
    
    def __init__(self, interval_ms=1000, callback=None):
        self.interval_ms = interval_ms
        self.callback = callback
        self.running = Event()
        self.thread = None
        self.data_buffer = []
        
    def start(self):
        """启动监控"""
        self.running.set()
        self.thread = Thread(target=self._monitor_loop)
        self.thread.daemon = True
        self.thread.start()
        
    def stop(self):
        """停止监控"""
        self.running.clear()
        if self.thread:
            self.thread.join(timeout=5)
            
    def _monitor_loop(self):
        """监控主循�?""
        while self.running.is_set():
            timestamp = time.time()
            metrics = self._collect_metrics(timestamp)
            
            # 存储到缓冲区
            self.data_buffer.append(metrics)
            
            # 回调通知
            if self.callback:
                self.callback(metrics)
                
            time.sleep(self.interval_ms / 1000)
            
    def _collect_metrics(self, timestamp):
        """采集各项性能指标"""
        # CPU
        cpu_percent = psutil.cpu_percent(interval=0.1)
        
        # 内存
        mem = psutil.virtual_memory()
        
        # 磁盘 IO
        disk_io = psutil.disk_io_counters()
        
        # 网络 IO
        net_io = psutil.net_io_counters()
        
        # GPU（如有）
        gpu_info = self._collect_gpu_metrics()
        
        return {
            "timestamp": timestamp,
            "cpu": {
                "percent": cpu_percent,
                "per_cpu": psutil.cpu_percent(interval=0.1, percpu=True)
            },
            "memory": {
                "total_gb": mem.total / (1024**3),
                "used_gb": mem.used / (1024**3),
                "percent": mem.percent
            },
            "disk": {
                "read_bytes_ps": disk_io.read_bytes / 1024 / 1024,  # MB/s
                "write_bytes_ps": disk_io.write_bytes / 1024 / 1024,
                "read_count_ps": disk_io.read_count,
                "write_count_ps": disk_io.write_count
            },
            "network": {
                "sent_mbps": net_io.bytes_sent / 1024 / 1024 * 8,
                "recv_mbps": net_io.bytes_recv / 1024 / 1024 * 8
            },
            "gpu": gpu_info
        }
        
    def _collect_gpu_metrics(self):
        """采集 GPU 指标"""
        try:
            gpus = GPUtil.getGPUs()
            if gpus:
                gpu = gpus[0]
                return {
                    "present": True,
                    "usage_percent": gpu.load * 100,
                    "memory_percent": gpu.memoryUtil * 100,
                    "memory_used_mb": gpu.memoryUsed,
                    "temperature_c": gpu.temperature
                }
        except:
            pass
            
        return {"present": False}
```

### 6.4 任务执行引擎

#### 6.4.1 任务解析与执�?
```python
import json
import subprocess
import time
from abc import ABC, abstractmethod

class TaskExecutor:
    """测试任务执行引擎"""
    
    def __init__(self, task_config, callback=None):
        self.task_config = task_config
        self.callback = callback
        self.current_step = 0
        self.results = []
        
    def execute(self):
        """执行完整任务"""
        operations = self.task_config.get("operations", [])
        
        for idx, operation in enumerate(operations):
            self.current_step = idx
            
            # 触发步骤开始回�?            if self.callback:
                self.callback("step_start", {
                    "step": idx,
                    "total_steps": len(operations),
                    "operation": operation.get("name")
                })
            
            # 执行操作
            result = self._execute_operation(operation)
            self.results.append(result)
            
            # 触发步骤完成回调
            if self.callback:
                self.callback("step_complete", {
                    "step": idx,
                    "result": result
                })
                
        return self._compile_results()
        
    def _execute_operation(self, operation):
        """执行单个操作"""
        op_type = operation.get("type")
        op_name = operation.get("name")
        
        start_time = time.time()
        
        try:
            if op_type == "gather":
                result = self._execute_gather(operation)
            elif op_type == "benchmark":
                result = self._execute_benchmark(operation)
            elif op_type == "operation":
                result = self._execute_operation_action(operation)
            else:
                raise ValueError(f"Unknown operation type: {op_type}")
                
            success = True
            error = None
            
        except Exception as e:
            success = False
            error = str(e)
result = None
            
        duration = time.time() - start_time
        
        return {
            "name": op_name,
            "type": op_type,
            "success": success,
            "duration": duration,
            "result": result,
            "error": error,
            "timestamp": start_time
        }
        
    def _execute_benchmark(self, operation):
        """执行基准测试"""
        tool = operation.get("params", {}).get("tool")
        
        if tool == "cinebench":
            return self._run_cinebench(operation)
        elif tool == "blender":
            return self._run_blender_benchmark(operation)
        elif tool == "crystaldiskmark":
            return self._run_diskmark(operation)
        else:
            raise ValueError(f"Unknown benchmark tool: {tool}")
            
    def _run_cinebench(self, operation):
        """运行 Cinebench 测试"""
        params = operation.get("params", {})
        
        # 构建命令行参�?        cmd = [
            "Cinebench.exe",
            "-g_CinebenchCpuMulti=true" if params.get("multi_core") else "-g_CinebenchCpuMulti=false",
            f"-g_CinebenchMinimumTestDuration={params.get('min_test_duration', 60)}"
        ]
        
        # 静默运行
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=operation.get("timeout", 300)
        )
        
        # 解析输出获取分数
        output = result.stdout + result.stderr
        score = self._parse_cinebench_output(output)
        
        return {
            "tool": "cinebench",
            "score": score,
            "output": output
        }
        
    def _run_blender_benchmark(self, operation):
        """运行 Blender Benchmark"""
        params = operation.get("params", {})
        
        cmd = [
            "blender",
            "-b",  # 后台模式
            "-o", "\\\\temp\\benchmark_",
            "-a",  # 运行动画渲染
            f"\\\\fileserver\\test_assets\\{params.get('scene', 'bmw27')}.blend"
        ]
        
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=operation.get("timeout", 600)
        )
        
        # 解析渲染时间
        render_time = self._parse_blender_output(result.stdout)
        
        return {
            "tool": "blender",
            "render_time_seconds": render_time,
            "scene": params.get("scene")
        }
        
    def _execute_operation_action(self, operation):
        """执行模拟操作（如打开软件、视口测试等�?""
        action = operation.get("action")
        
        if action == "launch_app":
            return self._launch_application(operation)
        elif action == "viewport_test":
            return self._viewport_performance_test(operation)
        elif action == "render_test":
            return self._render_test(operation)
        else:
            raise ValueError(f"Unknown action: {action}")
```

### 6.5 操作模拟模块

#### 6.5.1 应用程序启动测试

```python
import subprocess
import time

def launch_application_with_timing(app_path, wait_ready=60, window_title_pattern=None):
    """启动应用程序并测量启动时�?""
    start_time = time.time()
    
    # 启动进程
    process = subprocess.Popen(
        [app_path],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE
    )
    
    # 等待程序就绪
    ready_time = None
    if window_title_pattern:
        # 等待窗口出现
        ready_time = wait_for_window(window_title_pattern, timeout=wait_ready)
    else:
        # 简单等�?        time.sleep(min(wait_ready, 10))
        ready_time = time.time() - start_time
        
    startup_time = time.time() - start_time
    
    # 检查进程是否成功启�?    poll = process.poll()
    if poll is not None:
        # 进程已退�?        return {
            "success": False,
            "startup_time": startup_time,
            "error": f"进程退出，代码: {poll}"
        }
        
    return {
        "success": True,
        "startup_time": startup_time,
        "ready_time": ready_time,
        "pid": process.pid
    }

def wait_for_window(title_pattern, timeout=60):
    """等待指定窗口出现"""
    import win32gui
    import win32con
    
    start_time = time.time()
    
    while time.time() - start_time < timeout:
        # 枚举所有窗�?        def callback(hwnd, windows):
            if win32gui.IsWindowVisible(hwnd):
                title = win32gui.GetWindowText(hwnd)
                if title_pattern.lower() in title.lower():
                    windows.append(hwnd)
            return True
            
        windows = []
        win32gui.EnumWindows(callback, windows)
        
        if windows:
            return time.time() - start_time
            
        time.sleep(0.5)
        
    return None
```

#### 6.5.2 视口帧率测试

```python
import pyautogui
import time
import win32gui
import win32con
from ctypes import windll

def viewport_performance_test(app_process_name, scene_file, duration=30, modes=None):
    """测试 DCC 软件视口性能"""
    if modes is None:
        modes = ["wireframe", "shaded"]
        
    results = []
    
    # 激活目标窗�?    hwnd = find_window_by_process(app_process_name)
    if not hwnd:
        return {"error": "未找到目标窗�?}
        
    windll.user32.SetForegroundWindow(hwnd)
    time.sleep(0.5)
    
    for mode in modes:
        # 切换视口模式
        switch_viewport_mode(mode)
        time.sleep(2)
        
        # 采集帧率数据
        fps_data = []
        start_time = time.time()
        
        while time.time() - start_time < duration:
            # 执行旋转操作
            perform_rotation(duration=0.5)
            
            # 记录帧率（通过 GPU 负载间接估算�?            fps_data.append(estimate_fps_from_gpu_load())
            time.sleep(0.1)
            
        results.append({
            "mode": mode,
            "avg_fps": sum(fps_data) / len(fps_data) if fps_data else 0,
            "min_fps": min(fps_data) if fps_data else 0,
            "max_fps": max(fps_data) if fps_data else 0,
            "samples": len(fps_data)
        })
        
    return {
        "scene_file": scene_file,
        "results": results
    }
```

### 6.6 数据上报模块

#### 6.6.1 HTTP 上报

```python
import requests
import json
import time

class DataReporter:
    """数据上报模块"""
    
    def __init__(self, server_url, device_key):
        self.server_url = server_url
        self.device_key = device_key
        self.session = requests.Session()
        self.session.headers.update({
            "Content-Type": "application/json",
            "X-Device-Key": device_key
        })
        
    def report_result(self, result_data):
        """上报测试结果"""
        url = f"{self.server_url}/api/v1/agent/upload"
        
        try:
            response = self.session.post(url, json=result_data, timeout=60)
            response.raise_for_status()
            return {"success": True, "response": response.json()}
        except Exception as e:
            # 缓存到本地待重试
            self._cache_result(result_data)
            return {"success": False, "error": str(e)}
            
    def report_metrics_batch(self, metrics_list):
        """批量上报性能数据"""
        url = f"{self.server_url}/api/v1/agent/metrics"
        
        payload = {
            "device_key": self.device_key,
            "metrics": metrics_list,
            "timestamp": time.time()
        }
        
        try:
            response = self.session.post(url, json=payload, timeout=30)
            return {"success": True}
        except Exception as e:
            return {"success": False, "error": str(e)}
            
    def _cache_result(self, result_data):
        """缓存失败的结果到本地文件"""
        cache_file = f"results_cache_{int(time.time())}.json"
        with open(cache_file, "w", encoding="utf-8") as f:
            json.dump(result_data, f, ensure_ascii=False, indent=2)
```

---

## 第七�?前端设计与实�?
### 7.1 前端项目结构

```
frontend/
├── public/
�?  └── favicon.ico
├── src/
�?  ├── api/                    # API 接口定义
�?  �?  ├── index.ts            # Axios 实例配置
�?  �?  ├── auth.ts             # 认证相关接口
�?  �?  ├── devices.ts          # 设备管理接口
�?  �?  ├── tasks.ts            # 测试任务接口
�?  �?  ├── results.ts          # 测试结果接口
�?  �?  ├── standards.ts        # 配置标准接口
�?  �?  └── dashboard.ts        # 仪表盘接�?�?  ├── assets/                 # 静态资�?�?  �?  └── styles/
�?  �?      └── main.scss       # 全局样式
�?  ├── components/            # 公共组件
�?  �?  ├── common/             # 通用组件
�?  �?  ├── charts/             # 图表组件
�?  �?  └── layout/             # 布局组件
�?  ├── composables/            # 组合式函�?�?  �?  ├── useDevice.ts
�?  �?  ├── useTask.ts
�?  �?  └── useWebSocket.ts
�?  ├── router/                 # 路由配置
�?  �?  └── index.ts
�?  ├── stores/                 # Pinia 状态管�?�?  �?  ├── user.ts
�?  �?  ├── devices.ts
�?  �?  └── tasks.ts
�?  ├── views/                  # 页面视图
�?  �?  ├── Login.vue
�?  �?  ├── Dashboard.vue
�?  �?  ├── Devices/
�?  �?  �?  ├── DeviceList.vue
�?  �?  �?  └── DeviceDetail.vue
�?  �?  ├── Tasks/
�?  �?  �?  ├── TaskList.vue
�?  �?  �?  └── TaskCreate.vue
�?  �?  ├── Results/
�?  �?  �?  ├── ResultList.vue
�?  �?  �?  └── ResultDetail.vue
�?  �?  ├── Standards/
�?  �?  �?  └── StandardManage.vue
�?  �?  └── Settings.vue
�?  ├── App.vue
�?  └── main.ts
├── index.html
├── vite.config.ts
├── tsconfig.json
└── package.json
```

### 7.2 核心页面设计

#### 7.2.1 仪表盘页面（Dashboard.vue�?
仪表盘是系统首页，展示整体运行态势和数据概览。页面布局采用顶部统计卡片 + 左侧导航 + 右侧内容区的经典企业后台布局�?
顶部区域展示 4 个核心统计卡片：在线设备数量、今日测试次数、配置达标率、待处理告警数量。每个卡片用大号数字突出显示关键指标，配以趋势箭头指示同比变化�?
页面主体分为左右两栏：左侧为部门性能排名，以柱状图形式展示各部门平均性能得分；右侧为最近测试任务列表，以时间线形式展示最�?10 条测试任务及其状态�?
页面底部为性能趋势折线图，默认展示最�?7 天的系统性能变化趋势，支持按 CPU、内存、GPU、磁盘等维度切换�?
#### 7.2.2 设备管理页面（DeviceList.vue�?
设备列表页面展示所有已注册的终端设备信息，支持分页、筛选、搜索和批量操作�?
表格列包括：设备名称、MAC 地址、所属部门、岗位类型、CPU 型号、显卡型号、内存容量、在线状态、最后活跃时间。状态列通过颜色区分在线（绿色）、离线（灰色）、测试中（蓝色）、异常（红色）�?
支持的操作包括：查看详情（跳转到设备详情页）、创建测试任务（选中设备后点击测试按钮）、编辑设备信息、删除设备�?
#### 7.2.3 测试结果详情页面（ResultDetail.vue�?
测试结果详情是系统的核心页面，用于展示单次测试的完整数据和达标判定结果�?
页面分为以下几个区块�?
测试概览区块以信息卡片形式展示测试基本信息，包括测试时间、持续时长、测试类型、关联设备、测试状态�?
硬件配置区块展示被测电脑的硬件配置信息，与配置标准中的要求进行对比，以表格形式列出各项硬件指标的当前值和最低要求值�?
性能得分区块使用雷达图展示各项性能指标的得分情况，包括 CPU、内存、GPU、磁盘、综合得分。雷达图中心�?0 分，边缘�?100 分，得分越接近边缘表示性能越好�?
达标判定区块以状态卡片形式展示判定结果。绿色卡片表示全部达标，黄色卡片表示部分指标接近阈值（建议观察），红色卡片表示存在不达标项需要升级�?
不达标原因区块详细列出所有未达标的指标项，说明当前值与要求的差距。不达标项以红色高亮显示�?
瓶颈分析区块使用流程图或树状图展示性能瓶颈分析结果，清晰指出影响最大的硬件瓶颈�?
升级建议区块以卡片列表形式展示推荐的升级方案，包括建议更换的硬件型号、预估费用、性能提升预期�?
性能曲线区块使用 ECharts 折线图展示测试过程中的实时性能数据变化，支持选择 CPU、内存、GPU、磁盘等不同指标进行查看，支持缩放和平移操作�?
#### 7.2.4 配置标准管理页面（StandardManage.vue�?
配置标准管理页面用于维护不同岗位的配置要求标准。页面左侧为岗位列表，右侧为选中岗位的详细配置项�?
配置项分组展示：处理器要求（核心数、线程数、PassMark 分数、满载阈值）、内存要求（最小容量、使用率阈值）、显卡要求（型号匹配、显存大小、分数、使用率阈值）、存储要求（容量、读写速度、IOPS）、业务场景要求（编译耗时、视口帧率、渲染耗时、软件启动时间）�?
每个配置项支持编辑和删除操作，页面底部有新增配置标准的按钮�?
### 7.3 核心组件设计

#### 7.3.1 性能曲线图表组件

```vue
<template>
  <div class="performance-chart">
    <n-card>
      <template #header>
        <div class="chart-header">
          <span>{{ title }}</span>
          <n-radio-group v-model:value="metricType" size="small">
            <n-radio-button value="cpu">CPU</n-radio-button>
            <n-radio-button value="memory">内存</n-radio-button>
            <n-radio-button value="gpu">GPU</n-radio-button>
            <n-radio-button value="disk">磁盘</n-radio-button>
          </n-radio-group>
        </div>
      </template>
      <v-chart :option="chartOption" :autoresize="true" style="height: 300px" />
    </n-card>
  </div>
</template>

<script setup lang="ts">
import { computed, ref, watch } from 'vue'
import { use } from 'echarts/core'
import { CanvasRenderer } from 'echarts/renderers'
import { LineChart } from 'echarts/charts'
import { GridComponent, TooltipComponent, LegendComponent, DataZoomComponent } from 'echarts/components'
import VChart from 'vue-echarts'

use([CanvasRenderer, LineChart, GridComponent, TooltipComponent, LegendComponent, DataZoomComponent])

const props = defineProps<{
  title: string
  data: Array<{ timestamp: string; value: number }>
  color?: string
}>()

const metricType = ref('cpu')

const chartOption = computed(() => ({
  tooltip: {
    trigger: 'axis',
    formatter: (params: any) => {
      const item = params[0]
      return `${item.name}<br/>${item.seriesName}: ${item.value.toFixed(1)}%`
    }
  },
  grid: {
    left: '3%',
    right: '4%',
    bottom: '15%',
    top: '10%',
    containLabel: true
  },
  xAxis: {
    type: 'category',
    boundaryGap: false,
    data: props.data.map(d => d.timestamp),
    axisLabel: {
      formatter: (value: string) => {
        const date = new Date(value)
        return `${date.getHours()}:${date.getMinutes().toString().padStart(2, '0')}`
      }
    }
  },
  yAxis: {
    type: 'value',
    min: 0,
    max: 100,
    axisLabel: {
      formatter: '{value}%'
    }
  },
  dataZoom: [
    {
      type: 'inside',
      start: 0,
      end: 100
    },
    {
      type: 'slider',
      start: 0,
      end: 100
    }
  ],
  series: [
    {
      name: metricType.value.toUpperCase(),
      type: 'line',
      smooth: true,
      symbol: 'none',
      areaStyle: {
        color: props.color || '#3B82F6'
      },
      lineStyle: {
        color: props.color || '#3B82F6',
        width: 2
      },
      data: props.data.map(d => d.value)
    }
  ]
}))
</script>
```

#### 7.3.2 达标判定卡片组件

```vue
<template>
  <n-card :class="['result-card', statusClass]">
    <div class="result-content">
      <div class="result-icon">
        <n-icon :size="48">
          <CheckCircleFilled v-if="isPass" />
          <CloseCircleFilled v-else-if="isFail" />
          <WarningFilled v-else />
        </n-icon>
      </div>
      <div class="result-info">
        <h3>{{ title }}</h3>
        <p>{{ description }}</p>
        <div v-if="failReasons.length > 0" class="fail-reasons">
          <n-tag v-for="reason in failReasons" :key="reason" type="error" size="small">
            {{ reason }}
          </n-tag>
        </div>
      </div>
    </div>
  </n-card>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { CheckCircleFilled, CloseCircleFilled, WarningFilled } from '@vicons/ionicons5'

const props = defineProps<{
  status: 'passed' | 'failed' | 'warning'
  title: string
  description: string
  failReasons?: string[]
}>()

const isPass = computed(() => props.status === 'passed')
const isFail = computed(() => props.status === 'failed')

const statusClass = computed(() => ({
  'status-passed': isPass.value,
  'status-failed': isFail.value,
  'status-warning': props.status === 'warning'
}))
</script>

<style scoped lang="scss">
.result-card {
  margin-bottom: 16px;
  
  &.status-passed {
    border-left: 4px solid #10B981;
    
    .result-icon {
      color: #10B981;
    }
  }
  
  &.status-failed {
    border-left: 4px solid #EF4444;
    
    .result-icon {
      color: #EF4444;
    }
  }
  
  &.status-warning {
    border-left: 4px solid #F59E0B;
    
    .result-icon {
      color: #F59E0B;
    }
  }
  
  .result-content {
    display: flex;
    align-items: flex-start;
    gap: 16px;
    
    .result-icon {
      flex-shrink: 0;
    }
    
    .result-info {
      flex: 1;
      
      h3 {
        margin: 0 0 8px;
        font-size: 18px;
      }
      
      p {
        margin: 0;
        color: #666;
      }
      
      .fail-reasons {
        margin-top: 12px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
    }
  }
}
</style>
```

#### 7.3.3 雷达图组�?
```vue
<template>
  <v-chart :option="chartOption" :autoresize="true" style="height: 350px" />
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { use } from 'echarts/core'
import { CanvasRenderer } from 'echarts/renderers'
import { RadarChart } from 'echarts/charts'
import { RadarComponent, TooltipComponent, LegendComponent } from 'echarts/components'
import VChart from 'vue-echarts'

use([CanvasRenderer, RadarChart, RadarComponent, TooltipComponent, LegendComponent])

const props = defineProps<{
  indicators: Array<{ name: string; value: number; max: number }>
  colors?: string[]
}>()

const chartOption = computed(() => ({
  tooltip: {},
  radar: {
    indicator: props.indicators.map(ind => ({
      name: ind.name,
      max: ind.max
    })),
    radius: '65%',
    shape: 'polygon',
    splitNumber: 5,
    axisName: {
      color: '#666'
    },
    splitArea: {
      areaStyle: {
        color: ['rgba(255, 255, 255, 0.02)', 'rgba(255, 255, 255, 0.04)']
      }
    }
  },
  series: [
    {
      type: 'radar',
      data: [
        {
          value: props.indicators.map(ind => ind.value),
          name: '当前配置',
          areaStyle: {
            color: props.colors?.[0] || 'rgba(59, 130, 246, 0.3)'
          },
          lineStyle: {
            color: props.colors?.[0] || '#3B82F6'
          },
          itemStyle: {
            color: props.colors?.[0] || '#3B82F6'
          }
        },
        {
          value: props.indicators.map(() => 100),
          name: '标准要求',
          areaStyle: {
            color: 'rgba(16, 185, 129, 0.1)'
          },
          lineStyle: {
            color: '#10B981',
            type: 'dashed'
          },
          itemStyle: {
            color: '#10B981'
          }
        }
      ]
    }
  ]
}))
</script>
```

---

## 第八�?部署方案

### 8.1 Docker Compose 部署

#### 8.1.1 docker-compose.yml

```yaml
version: '3.8'

services:
  # PostgreSQL 数据�?  postgres:
    image: postgres:15-alpine
    container_name: benchmark_postgres
    environment:
      POSTGRES_USER: benchmark
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: benchmark_db
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U benchmark"]
      interval: 10s
      timeout: 5s
      retries: 5

  # InfluxDB 时序数据�?  influxdb:
    image: influxdb:2.7
    container_name: benchmark_influxdb
    environment:
      DOCKER_INFLUXDB_INIT_MODE: setup
      DOCKER_INFLUXDB_INIT_USERNAME: benchmark
      DOCKER_INFLUXDB_INIT_PASSWORD: ${INFLUXDB_PASSWORD}
      DOCKER_INFLUXDB_INIT_ORG: benchmark
      DOCKER_INFLUXDB_INIT_BUCKET: metrics
      DOCKER_INFLUXDB_INIT_ADMIN_TOKEN: ${INFLUXDB_TOKEN}
    volumes:
      - influxdb_data:/var/lib/influxdb2
      - influxdb_config:/etc/influxdb2
    ports:
      - "8086:8086"
    healthcheck:
      test: ["CMD", "influx", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis 缓存与消息队�?  redis:
    image: redis:7-alpine
    container_name: benchmark_redis
    command: redis-server --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # 后端 API 服务
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: benchmark_backend
    environment:
      - DATABASE_URL=postgresql://benchmark:${POSTGRES_PASSWORD}@postgres:5432/benchmark_db
      - INFLUXDB_URL=http://influxdb:8086
      - INFLUXDB_TOKEN=${INFLUXDB_TOKEN}
      - INFLUXDB_ORG=benchmark
      - INFLUXDB_BUCKET=metrics
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/0
      - SECRET_KEY=${SECRET_KEY}
      - CORS_ORIGINS=http://localhost:5173,http://localhost:80
    ports:
      - "8000:8000"
    depends_on:
      postgres:
        condition: service_healthy
      influxdb:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
    volumes:
      - ./backend/app:/app/app
      - upload_data:/app/uploads

  # 前端 Web 服务
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: benchmark_frontend
    ports:
      - "80:80"
    depends_on:
      - backend
    restart: unless-stopped
    volumes:
      - ./frontend/nginx.conf:/etc/nginx/nginx.conf:ro

volumes:
  postgres_data:
  influxdb_data:
  influxdb_config:
  redis_data:
  upload_data:
```

#### 8.1.2 环境变量文件 .env

```bash
# 数据库密�?POSTGRES_PASSWORD=YourSecurePostgresPassword123!

# InfluxDB 配置
INFLUXDB_PASSWORD=YourSecureInfluxDBPassword123!
INFLUXDB_TOKEN=YourSecureInfluxDBToken12345678901234567890

# Redis 密码
REDIS_PASSWORD=YourSecureRedisPassword123!

# JWT 密钥
SECRET_KEY=YourVeryLongAndSecureSecretKeyForJWTTokenGeneration123456789

# 时区
TZ=Asia/Shanghai
```

### 8.2 服务启动命令

```bash
# 启动所有服�?docker-compose up -d

# 查看服务状�?docker-compose ps

# 查看日志
docker-compose logs -f

# 停止所有服�?docker-compose down

# 重新构建并启�?docker-compose up -d --build
```

### 8.3 客户�?Agent 部署

客户�?Agent 无需安装，通过以下方式部署�?
方式一：通过域控推送。使�?Active Directory 组策略或 SCCM 等企业部署工具，�?Agent 程序推送到目标电脑�?
方式二：通过共享目录。放置在内部文件服务器共享目录，目标电脑通过脚本自动拉取并运行�?
方式三：通过前端页面下载。登�?Web 管理平台，在设备管理页面有下�?Agent 的入口，IT 人员手动下载安装�?
Agent 程序配置说明：首次运�?Agent 时，需要在程序目录放置 config.json 配置文件，内容如下：

```json
{
  "server_url": "http://your-server-ip:8000",
  "device_key": "",
  "auto_register": true,
  "heartbeat_interval": 30,
  "data_upload_interval": 5,
  "log_level": "INFO"
}
```

---

## 第九�?开发计划与里程�?
### 9.1 开发阶段划�?
本系统开发分为四个主要阶段，总周期预�?6 �?8 周�?
第一阶段（第 1 �?2 周）为基础设施搭建阶段，完成后端项目初始化与框架搭建、前端项目初始化�?UI 框架配置、数据库表结构设计与初始化、基础设施 Docker 环境搭建。本阶段结束时产出可运行的空白项目框架�?
第二阶段（第 3 �?4 周）为核心功能开发阶段，完成客户�?Agent 硬件信息采集模块开发、客户端 Agent 性能监控模块开发、后端设备注册与心跳接口开发、前端设备列表页面开发、基础性能数据采集与存储流程打通。本阶段结束�?Agent 可注册到服务器并上报硬件信息�?
第三阶段（第 5 �?6 周）为测试能力构建阶段，完成任务执行引擎开发、测试脚本解析与执行模块开发、基准测试工具集成（ Cinebench、Blender 等）、前端测试任务管理页面开发、前端测试结果详情页面开发。本阶段结束时系统具备完整的测试执行和结果展示能力�?
第四阶段（第 7 �?8 周）为分析能力完善阶段，完成配置达标判定逻辑开发、瓶颈分析算法实现、升级建议生成模块开发、数据可视化大屏完善、前端数据看板开发、系统测试与 Bug 修复、部署文档编写与试运行。本阶段结束时系统具备完整的配置分析和决策支持能力�?
### 9.2 里程碑检查点

| 里程�?| 时间 | 完成标志 |
|--------|------|----------|
| M1：框架搭建完�?| �?2 周末 | 后端、前端可运行，数据库连接正常 |
| M2：设备管理上�?| �?4 周末 | Agent 可注册，设备列表页面可查�?|
| M3：测试执行贯�?| �?6 周末 | 任务可下发执行，结果页面可查�?|
| M4：完整系统上�?| �?8 周末 | 所有功能可用，系统稳定运行 |

---

## 第十�?附录

### 10.1 技术术语解�?
| 术语 | 说明 |
|------|------|
| Agent | 部署在客户端的代理程序，负责执行测试任务和采集数�?|
| Benchmark | 基准测试，使用标准化的测试工具评估硬件性能 |
| Bottleneck | 性能瓶颈，限制系统整体性能的关键组�?|
| PassMark | 一款综合性的硬件基准测试评分软件 |
| InfluxDB | 专为时序数据设计的数据库，适合存储性能监控数据 |
| JWT | JSON Web Token，一种安全的身份认证机制 |
| WebSocket | 双向实时通信协议，用于实时数据传�?|

### 10.2 配置标准参考�?
以下是常见游戏开发岗位的配置标准参考值，实际使用时需根据项目需求调整：

| 岗位类型 | CPU 最低要�?| 内存最低要�?| 显卡最低要�?| 存储要求 |
|----------|--------------|--------------|--------------|----------|
| 程序开�?| 6 �?12 线程 | 32GB | GTX 3060 12GB | 1TB NVMe |
| 3D 美术 | 8 �?16 线程 | 64GB | RTX 4070 12GB | 2TB NVMe |
| 动作特效 | 8 �?16 线程 | 32GB | RTX 4080 16GB | 1TB NVMe |
| UI 设计 | 6 �?12 线程 | 16GB | GTX 3060 12GB | 512GB NVMe |
| 测试 QA | 6 �?12 线程 | 16GB | GTX 1660 6GB | 512GB NVMe |

### 10.3 参考资源链�?
| 资源 | 链接 |
|------|------|
| FastAPI 官方文档 | https://fastapi.tiangolo.com/ |
| Vue 3 官方文档 | https://vuejs.org/ |
| Naive UI 官方文档 | https://www.naiveui.com/ |
| ECharts 官方文档 | https://echarts.apache.org/ |
| InfluxDB 官方文档 | https://docs.influxdata.com/influxdb/ |
| psutil 官方文档 | https://psutil.readthedocs.io/ |
| PyAutoGUI 官方文档 | https://pyautogui.readthedocs.io/ |

---
---

## 第十一章 安全设计

### 11.1 安全设计原则

本系统的安全设计遵循以下核心原则：

纵深防御：通过多层安全防护机制，即使某一层被突破，其他层仍能提供保护。最小权限：每个用户和服务只拥有完成其工作所必需的最小权限集。默认安全：系统在默认配置下即为安全状态，无需额外配置即可抵御常见威胁。可审计性：所有关键操作都有完整的审计日志，支持安全事件回溯和责任认定。

### 11.2 认证与授权

#### 11.2.1 JWT Token 认证机制

系统采用双 Token 机制进行身份认证：

Access Token：用于 API 请求的身份凭证，有效期 2 小时，存储在内存中。Refresh Token：用于刷新 Access Token，有效期 7 天，存储在 HttpOnly Cookie 中。Token 包含用户 ID、角色、过期时间等信息，采用 RS256 算法签名。

Token 刷新流程：

```
1. 客户端检测到 Access Token 即将过期（剩余时间 < 5 分钟）
2. 自动向 /api/v1/auth/refresh 端点发送 Refresh Token
3. 服务器验证 Refresh Token 有效性
4. 返回新的 Access Token 和 Refresh Token（Refresh Token 轮换）
5. 客户端更新本地存储的 Token
```

#### 11.2.2 权限控制模型

系统采用 RBAC（基于角色的访问控制）模型：

| 角色 | 权限说明 |
|------|----------|
| admin | 超级管理员，拥有所有权限，包括用户管理、系统配置 |
| operator | 操作员，可执行测试任务、查看结果、管理设备 |
| viewer | 查看者，仅可查看数据，不能执行任何修改操作 |

### 11.3 数据安全

#### 11.3.1 传输安全

所有数据传输均采用 HTTPS/TLS 加密：

后端服务与 Agent 通信：使用 HTTPS 协议，强制 TLS 1.2+。前端与后端通信：使用 HTTPS，配置 HSTS 响应头。数据库连接：PostgreSQL 和 Redis 启用 SSL 连接。

#### 11.3.2 存储安全

敏感数据采用加密存储：密码加密使用 bcrypt 算法，敏感配置使用 AES-256-GCM 加密，数据库启用透明数据加密，备份文件使用 GPG 对称加密。

### 11.4 Agent 安全机制

设备认证采用 RSA 2048 密钥对，设备公钥注册到服务器建立身份，后续通信使用设备私钥签名请求，服务器验证签名。设备密钥存储在受保护的 Windows 凭据管理器中。

### 11.5 安全审计日志

系统记录登录登出、权限变更、配置变更、数据导出、设备操作、测试执行等审计事件，存储在 audit_logs 表中。

### 11.6 风险防控措施

SQL 注入防护使用 SQLAlchemy ORM 参数化查询。XSS 攻击防护使用 Content Security Policy。CSRF 攻击防护使用 CSRF Token。DDoS 攻击防护使用 Nginx 限流。暴力破解防护使用登录失败锁定机制。

---

## 第十二章 性能优化

### 12.1 性能优化策略概述

本系统的性能优化遵循以下策略：先测量后优化，通过性能监控和压测找出瓶颈；读写分离，将读操作分流到只读副本；缓存为王，充分利用多级缓存；异步处理，将耗时操作异步化。

### 12.2 数据库性能优化

PostgreSQL 优化配置：shared_buffers 设为系统内存 25%，effective_cache_size 设为系统内存 75%，work_mem 设为 256MB。使用 B-tree 索引，定期分析查询计划调整索引。

InfluxDB 优化：批量写入减少网络往返，启用数据压缩，设置合理的保留策略。

Redis 缓存优化：设备在线状态 TTL 120秒，任务执行进度 TTL 10秒，使用 allkeys-lru 淘汰策略。

### 12.3 API 性能优化

采用游标分页优化大数据量查询，允许字段过滤减少数据传输，使用连接池配置提升数据库访问效率。

### 12.4 前端性能优化

Vite 构建优化：启用 terser 压缩，移除 console.log，代码分割优化。路由懒加载，按需加载组件。

### 12.5 Agent 性能优化

采样间隔自适应，高负载时自动延长采集间隔。内存占用限制在 100MB。数据上报使用 zlib 压缩。

### 12.6 性能监控指标

| 指标 | 目标值 |
|------|--------|
| API 响应时间 P95 | < 200ms |
| API 响应时间 P99 | < 500ms |
| 并发连接数 | > 500 |
| 数据库查询时间 | < 50ms |

---

## 第十三章 运维监控

### 13.1 监控体系架构

监控体系采用三层架构：指标采集层采集系统、应用、业务三级指标；数据存储层使用时序数据库存储监控数据；告警处理层基于规则实现告警通知。

### 13.2 日志管理规范

日志级别定义：DEBUG 用于开发调试，INFO 用于正常流程，WARNING 用于异常但不影响功能，ERROR 用于影响功能但可恢复，CRITICAL 用于系统级严重错误。

日志格式示例：`[2026-02-22 10:30:45] [INFO] [request_id:abc123] [user:admin] [module:auth] Login successful`

### 13.3 监控指标定义

系统级指标包括 CPU 使用率、内存使用率、磁盘使用率、网络带宽使用率。应用级指标包括 API 请求速率、API 响应时间、活跃连接数、错误率。业务级指标包括在线设备数、任务执行失败率、达标率。

### 13.4 告警规则配置

配置 CPU 使用率超过 80% 持续 5 分钟告警，内存使用率超过 85% 持续 5 分钟告警，API P95 响应时间超过 500ms 持续 3 分钟告警，错误率超过 1% 持续 2 分钟告警。

### 13.5 健康检查接口

实现系统健康检查端点 `/health`，返回数据库、Redis、InfluxDB 组件状态。实现 Kubernetes 存活探针 `/health/live` 和就绪探针 `/health/ready`。

### 13.6 监控大盘配置

Grafana 监控大盘展示 API 请求率、API 响应时间、在线设备数、今日测试数量、达标率等核心指标。

---

## 第十四章 测试策略

### 14.1 测试体系概述

本系统的测试体系包含以下层次：单元测试验证单个函数、方法的正确性；集成测试验证模块间交互的正确性；端到端测试验证完整业务流程；性能测试验证系统的性能指标。

### 14.2 测试技术栈

单元测试使用 pytest + pytest-asyncio，前端单元测试使用 Vitest，E2E 测试使用 Playwright，性能测试使用 Locust，代码覆盖率使用 coverage.py。

### 14.3 单元测试规范

单元测试文件位于 `tests/unit/` 目录，使用 pytest 框架，采用 Mock 技术隔离外部依赖，测试用例覆盖认证、设备管理、任务执行等核心功能。

### 14.4 集成测试规范

集成测试文件位于 `tests/integration/` 目录，测试 API 端点的完整流程，验证数据库操作的正确性，检查认证和授权机制。

### 14.5 前端测试规范

前端测试使用 Vitest 框架，测试组件渲染、交互逻辑、状态管理，采用 Vue Test Utils 进行组件挂载和模拟。

### 14.6 性能测试规范

性能测试使用 Locust 框架，模拟多用户并发访问 API，记录请求成功率、响应时间分布，找出系统瓶颈。

### 14.7 测试覆盖率要求

整体代码覆盖率要求 60% 最低、80% 目标。核心业务逻辑覆盖率要求 80% 最低、90% 目标。API 端点覆盖率要求 90% 最低、100% 目标。

---

## 第十五章 数据管理

### 15.1 数据备份策略

PostgreSQL 全量备份每天凌晨 2:00 执行，保留 30 天。InfluxDB 备份每天凌晨 3:00 执行，保留 90 天。Redis RDB 快照每 6 小时备份，保留 7 天。审计日志每月归档备份，保留 3 年。

### 15.2 数据恢复策略

提供 PostgreSQL 和 InfluxDB 的恢复脚本，支持从全量备份恢复，包含数据完整性和一致性验证。

### 15.3 数据迁移方案

使用 Alembic 进行数据库版本管理，支持迁移脚本的版本控制、回滚和验证。

### 15.4 数据生命周期管理

性能指标热存储 7 天、温存储 30 天、冷存储 1 年、2 年后删除。测试结果热存储 90 天、温存储 1 年、冷存储 3 年、5 年后删除。审计日志热存储 30 天、温存储 90 天、冷存储 3 年、7 年后删除。

### 15.5 数据同步与复制

PostgreSQL 配置主从复制，wal_level 设为 replica，max_wal_senders 设为 5。Redis 配置主从复制，实现读写分离和故障转移。

---

## 文档修订记录

| 版本 | 日期 | 修订内容 | 修订人 |
|------|------|----------|--------|
| V1.0.0 | 2026-02-22 | 初始版本发布 | 开发团队 |
| V1.1.0 | 2026-02-22 | 补充章节 11-15，完善安全、性能、监控、测试、数据管理相关内容 | Sisyphus |

---

## 文档结束

本文档为游戏公司终端性能基准测试与岗位配置分析系统的完整技术开发文档，涵盖系统架构设计、技术选型说明、数据库设计、API 接口定义、客户端 Agent 设计、前端实现、部署方案、开发计划及安全、性能、运维、测试、数据管理等内容。

文档版本：V1.1.0
最后更新：2026-02-22
